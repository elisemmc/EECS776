~What the program does

The program implements a simple real time running game using blank canvas for the graphics.  The program uses the arrow keys as controls for the small ship at the end of three lanes.  It also includes a simple scoring system based off of how long before you die.  If you dodge the "rocks" coming down the lanes the game will gradually speed up, increasing difficulty.  If you die, then you can restart from the beginning of the speed curve by pressing any key.

~Major design decisions

The first major decision was to have a single state variable control any variables in the game that required continuous updates.  A later, but necessary decision was to operate the game in two threads.  One thread was dedicated exclusively to tracking which keys are pressed and the second thread dedicated to running the game.  A design choice I made for simplicity was basing the movement of the rocks off of a changing delay rather than the more common strategy of varying the number of pixels that they moved per frame.  This is one decision that I would change if it ever caused a problem since this was mostly a decision based off of the fact that it was easier to incorperate into my program.

~Testing

Testing the final product was fairly simple since I could test just by playing the game.  Intermittently, however, I tested individual functions.  I first drew the lanes, which were a set width and varied in height based on the height of the screen.  Next I drew the rocks and made sure I could generate them anywhere in the lanes by calling their draw function with different lane and y parameters.  It was here I found that I needed a "shift" type that kept track of which lane an object was in.  Once familiar with drawing, I drew the ship and tested it the same way I tested the rocks.  I created a scrolling function that scrolled the rocks down the screen.  I then programmed the key inputs and moving the ship based on which keys were pressed.  This was the longest phase of testing since I did not initially program using two threads.  After this I implemented collision detection and made sure that the game ended when you crashed.  I actually implemented the game restart feature to make testing easier.

~Anything interesting/ challenges/ what you learned

The biggest challenge I faced was actually reading the key inputs in real time.  I had several attempts at the game that had some strange bugs.  My first attempt required that buttons be pushed in order for the game to advance.  This was a very interesting game to play since it required a lot of button-mashing and was very difficult to lose since you controlled how often the rocks updated.  The second attempt moved the ship and rocks in real time, but the ship would get stuck if you held the buttons down too long.  I found that this was because key-down triggered multiple times and I hadn't taken the "nub" of the list after updating.  This would force the ship to stop updating correctly.  After that, I had some interesting miscalculations with collision detection involving the y-axis being upside-down.  I'd forgotten that the upper-left corner of the screen was (0,0) so I'd managed to program collision detection completely upside-down.  Again, a really interesting game to attempt to play, but not a very hard thing to fix.